//! Implementation of the `rapina new` command.

use colored::Colorize;
use std::fs;
use std::path::Path;

use super::templates;

/// Execute the `new` command to create a new Rapina project.
///
/// `template` is `None` for the default starter and `Some("crud")` / `Some("auth")`
/// for the optional starter templates.
pub fn execute(name: &str, template: Option<&str>, no_ai: bool) -> Result<(), String> {
    validate_project_name(name)?;

    let project_path = Path::new(name);
    if project_path.exists() {
        return Err(format!("Directory '{}' already exists", name));
    }

    println!();
    println!(
        "  {} {}",
        "Creating new Rapina project:".bright_cyan(),
        name.bold()
    );
    println!();

    let src_path = project_path.join("src");
    fs::create_dir_all(&src_path).map_err(|e| format!("Failed to create directory: {}", e))?;

    match template {
        None => templates::rest_api::generate(name, project_path, &src_path)?,
        Some("crud") => templates::crud::generate(name, project_path, &src_path)?,
        Some("auth") => templates::auth::generate(name, project_path, &src_path)?,
        Some(other) => {
            return Err(format!(
                "Unknown template '{}'. Available: crud, auth",
                other
            ));
        }
    }

    // Create README.md
    let readme = generate_readme(name);
    fs::write(project_path.join("README.md"), readme)
        .map_err(|e| format!("Failed to write README.md: {}", e))?;
    println!("  {} Created {}", "âœ“".green(), "README.md".cyan());

    // Create AI assistant config files
    if !no_ai {
        let agent_path = project_path.join("AGENT.md");
        fs::write(&agent_path, generate_agent_md())
            .map_err(|e| format!("Failed to write AGENT.md: {}", e))?;
        println!("  {} Created {}", "âœ“".green(), "AGENT.md".cyan());

        let claude_dir = project_path.join(".claude");
        fs::create_dir_all(&claude_dir).map_err(|e| format!("Failed to create .claude/: {}", e))?;
        fs::write(claude_dir.join("CLAUDE.md"), generate_claude_md())
            .map_err(|e| format!("Failed to write .claude/CLAUDE.md: {}", e))?;
        println!("  {} Created {}", "âœ“".green(), ".claude/CLAUDE.md".cyan());

        let cursor_dir = project_path.join(".cursor");
        fs::create_dir_all(&cursor_dir).map_err(|e| format!("Failed to create .cursor/: {}", e))?;
        fs::write(cursor_dir.join("rules"), generate_cursor_rules())
            .map_err(|e| format!("Failed to write .cursor/rules: {}", e))?;
        println!("  {} Created {}", "âœ“".green(), ".cursor/rules".cyan());
    }

    println!();
    println!("  {} Project created successfully!", "ðŸŽ‰".bold());
    println!();
    println!("  {}:", "Next steps".bright_yellow());
    println!("    cd {}", name.cyan());
    println!("    rapina dev");
    println!();

    Ok(())
}

// â”€â”€ README â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn generate_readme(name: &str) -> String {
    format!(
        "# {name}\n\nA web application built with Rapina.\n\n## Getting started\n\n```bash\nrapina dev\n```\n\n## Routes\n\n- `GET /` â€” Hello world\n- `GET /health` â€” Health check\n"
    )
}

fn generate_agent_md() -> String {
    r#"# Rapina Project

This is a Rust web application built with [Rapina](https://github.com/arferreira/rapina), an opinionated web framework.

## Key Conventions

### Routes are protected by default
All routes require JWT authentication unless explicitly marked with `#[public]`:

```rust
#[public]
#[get("/health")]
async fn health() -> &'static str { "ok" }

// This route requires a valid JWT token
#[get("/me")]
async fn me(user: CurrentUser) -> Json<UserResponse> { ... }
```

### Handler pattern
Use proc macros for route registration. Handler names follow `verb_resource` convention:

```rust
#[get("/todos")]       async fn list_todos() -> ...
#[get("/todos/:id")]   async fn get_todo(id: Path<i32>) -> ...
#[post("/todos")]      async fn create_todo(body: Json<CreateTodo>) -> ...
#[put("/todos/:id")]   async fn update_todo(id: Path<i32>, body: Json<UpdateTodo>) -> ...
#[delete("/todos/:id")] async fn delete_todo(id: Path<i32>) -> ...
```

### Typed extractors
- `Json<T>` â€” request/response body (T must derive Serialize and/or Deserialize + JsonSchema)
- `Path<T>` â€” URL path parameter (`:id` syntax)
- `Query<T>` â€” query string parameters
- `State<T>` â€” shared application state
- `Validated<Json<T>>` â€” JSON body with validation (T must also derive Validate, returns 422 on failure)
- `CurrentUser` â€” authenticated user identity (requires auth to be configured)
- `Db` â€” database connection (requires database feature)

### Error handling
Return `Result<Json<T>>` from handlers. Use typed errors:

```rust
pub enum TodoError {
    DbError(DbError),
}

impl IntoApiError for TodoError {
    fn into_api_error(self) -> Error {
        match self {
            TodoError::DbError(e) => e.into_api_error(),
        }
    }
}
```

All error responses include a `trace_id` for debugging:
```json
{
  "error": { "code": "NOT_FOUND", "message": "Todo 42 not found" },
  "trace_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

### Project structure (feature-first)
```
src/
â”œâ”€â”€ main.rs          # App bootstrap with builder pattern
â”œâ”€â”€ entity.rs        # Database entities (schema! macro)
â”œâ”€â”€ migrations/      # Database migrations
â””â”€â”€ todos/           # Feature module (always plural)
    â”œâ”€â”€ mod.rs
    â”œâ”€â”€ handlers.rs  # Route handlers
    â”œâ”€â”€ dto.rs       # Request/response types
    â””â”€â”€ error.rs     # Domain errors
```

### Builder pattern
```rust
Rapina::new()
    .with_tracing(TracingConfig::new())
    .middleware(RequestLogMiddleware::new())
    .with_cors(CorsConfig::permissive())
    .router(router)
    .listen("127.0.0.1:3000")
    .await
```

## CLI Commands
- `rapina dev` â€” run with auto-reload
- `rapina doctor` â€” diagnose project issues
- `rapina routes` â€” list all registered routes
- `rapina add resource <name>` â€” scaffold a new CRUD resource
"#
    .to_string()
}

fn generate_claude_md() -> String {
    r#"# Rapina Project Instructions

This is a Rust web application built with the Rapina framework.

## Framework Overview

Rapina is an opinionated Rust web framework built on hyper. Routes are protected by default (JWT auth) unless marked `#[public]`. All response types must derive `Serialize` + `JsonSchema` for OpenAPI generation. Error responses always include a `trace_id`.

## Conventions

### Adding a new endpoint

1. Create or edit the handler in `src/<feature>/handlers.rs`
2. Use the proc macro: `#[get("/path")]`, `#[post("/path")]`, `#[put("/path")]`, `#[delete("/path")]`
3. Mark public routes with `#[public]` above the method macro
4. Use `#[errors(ErrorType)]` to document error responses for OpenAPI
5. If using `.discover()`, the route is auto-registered. Otherwise add it to the router in `main.rs`

### Extractors (in handler function signatures)

```rust
// Body (only one per handler)
body: Json<T>              // JSON body, T: Deserialize + JsonSchema
body: Validated<Json<T>>   // JSON body with validation, T: Deserialize + JsonSchema + Validate
body: Form<T>              // Form data

// Parts (multiple allowed)
id: Path<i32>              // URL path param (:id syntax)
params: Query<T>           // Query string
headers: Headers           // Full header map
state: State<T>            // App state
user: CurrentUser          // Authenticated user (id, claims)
ctx: Context               // Request context (trace_id, start_time)
db: Db                     // Database connection (requires database feature)
jar: Cookie<T>             // Cookie values
```

### Handler naming convention
- `list_<resources>` â€” GET collection
- `get_<resource>` â€” GET single item
- `create_<resource>` â€” POST
- `update_<resource>` â€” PUT
- `delete_<resource>` â€” DELETE

### Builder pattern
```rust
Rapina::new()
    .with_tracing(TracingConfig::new())
    .middleware(RequestLogMiddleware::new())
    .with_cors(CorsConfig::permissive())
    .router(router)
    .listen("127.0.0.1:3000")
    .await
```

### Error handling pattern

Each feature module has its own error type:

```rust
// src/todos/error.rs
pub enum TodoError {
    DbError(DbError),
}

impl IntoApiError for TodoError {
    fn into_api_error(self) -> Error {
        match self {
            TodoError::DbError(e) => e.into_api_error(),
        }
    }
}

impl DocumentedError for TodoError {
    fn error_variants() -> Vec<ErrorVariant> {
        vec![
            ErrorVariant { status: 404, code: "NOT_FOUND", description: "Todo not found" },
            ErrorVariant { status: 500, code: "DATABASE_ERROR", description: "Database operation failed" },
        ]
    }
}
```

Use `Error::not_found()`, `Error::bad_request()`, `Error::unauthorized()`, etc. for quick errors.

### Project structure

Feature-first modules. Each feature directory is plural:

```
src/todos/handlers.rs    # not src/handlers/todos.rs
src/todos/dto.rs         # CreateTodo, UpdateTodo structs
src/todos/error.rs       # TodoError enum
src/todos/mod.rs         # pub mod dto; pub mod error; pub mod handlers;
```

Top-level shared files:
- `src/entity.rs` â€” all database entities via `schema!` macro
- `src/migrations/` â€” database migrations via `migrations!` macro

### DTOs
- Request types: `Create<Resource>`, `Update<Resource>` â€” derive `Deserialize` + `JsonSchema`
- Response types: derive `Serialize` + `JsonSchema`
- Update DTOs wrap fields in `Option<T>` for partial updates

### Testing

```rust
use rapina::testing::TestClient;

#[tokio::test]
async fn test_hello() {
    let app = Rapina::new().router(router);
    let client = TestClient::new(app).await;

    let res = client.get("/").send().await;
    assert_eq!(res.status(), StatusCode::OK);

    let body: MessageResponse = res.json();
    assert_eq!(body.message, "Hello from Rapina!");
}
```

`TestClient` supports `.get()`, `.post()`, `.put()`, `.delete()`, `.patch()`. Request builder has `.json()`, `.header()`, `.body()`. Response has `.status()`, `.json::<T>()`, `.text()`.

## Build & Run

```bash
rapina dev              # development with auto-reload
cargo build --release   # production build
rapina doctor           # check for common issues
rapina routes           # list all routes
```
"#
    .to_string()
}

fn generate_cursor_rules() -> String {
    r#"# Rapina Framework Rules

This is a Rust project using the Rapina web framework.

## Route Handlers

- Use proc macros: `#[get("/path")]`, `#[post("/path")]`, `#[put("/path")]`, `#[delete("/path")]`
- All routes require JWT auth by default. Use `#[public]` for public routes
- Handler names: `list_todos`, `get_todo`, `create_todo`, `update_todo`, `delete_todo`
- Use `#[errors(ErrorType)]` to document error responses

## Extractors

- `Json<T>` for request/response bodies (T: Serialize/Deserialize + JsonSchema)
- `Validated<Json<T>>` for validated bodies (T: also Validate, returns 422)
- `Path<T>` for URL params (`:id` syntax)
- `Query<T>` for query strings
- `State<T>` for shared app state
- `CurrentUser` for the authenticated user
- `Db` for database connection
- Only one body extractor per handler

## Error Handling

- Return `Result<Json<T>>` from handlers
- Use `Error::not_found()`, `Error::bad_request()`, etc.
- Each feature has a typed error enum implementing `IntoApiError` + `DocumentedError`
- All errors include `trace_id` in the response

## Project Structure

Feature-first modules (plural names):
```
src/todos/handlers.rs   â€” route handlers
src/todos/dto.rs        â€” CreateTodo, UpdateTodo (Deserialize + JsonSchema)
src/todos/error.rs      â€” TodoError with IntoApiError + DocumentedError
src/todos/mod.rs        â€” pub mod dto; pub mod error; pub mod handlers;
src/entity.rs           â€” schema! macro for DB entities
src/migrations/         â€” database migrations
```

## Response Types

- Derive `Serialize` + `JsonSchema` on all response structs
- Derive `Deserialize` + `JsonSchema` on request structs
- Update DTOs use `Option<T>` for partial updates

## Builder Pattern

```rust
Rapina::new()
    .with_tracing(TracingConfig::new())
    .middleware(RequestLogMiddleware::new())
    .discover()  // auto-discover handlers
    .listen("127.0.0.1:3000")
    .await
```

## CLI

- `rapina dev` â€” development server with auto-reload
- `rapina doctor` â€” diagnose issues
- `rapina routes` â€” list routes
- `rapina add resource <name>` â€” scaffold CRUD resource
"#
    .to_string()
}

/// Validate that the project name is a valid Rust crate name.
fn validate_project_name(name: &str) -> Result<(), String> {
    if name.is_empty() {
        return Err("Project name cannot be empty".to_string());
    }

    if name.chars().next().unwrap().is_ascii_digit() {
        return Err("Project name cannot start with a digit".to_string());
    }

    for c in name.chars() {
        if !c.is_alphanumeric() && c != '_' && c != '-' {
            return Err(format!(
                "Project name contains invalid character: '{}'. Only alphanumeric characters, underscores, and hyphens are allowed.",
                c
            ));
        }
    }

    let reserved = ["test", "self", "super", "crate", "Self"];
    if reserved.contains(&name) {
        return Err(format!("'{}' is a reserved Rust keyword", name));
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_project_name_valid() {
        assert!(validate_project_name("my-app").is_ok());
        assert!(validate_project_name("my_app").is_ok());
        assert!(validate_project_name("myapp").is_ok());
        assert!(validate_project_name("myapp123").is_ok());
    }

    #[test]
    fn test_validate_project_name_invalid() {
        assert!(validate_project_name("").is_err());
        assert!(validate_project_name(".").is_err());
        assert!(validate_project_name("123app").is_err());
        assert!(validate_project_name("my app").is_err());
        assert!(validate_project_name("my.app").is_err());
        assert!(validate_project_name("self").is_err());
    }

    #[test]
    fn test_generate_agent_md() {
        let content = generate_agent_md();
        assert!(content.contains("Rapina"));
        assert!(content.contains("#[public]"));
        assert!(content.contains("trace_id"));
        assert!(content.contains("Json<T>"));
        assert!(content.contains("IntoApiError"));
        assert!(content.contains("rapina add resource"));
    }

    #[test]
    fn test_generate_claude_md() {
        let content = generate_claude_md();
        assert!(content.contains("Rapina"));
        assert!(content.contains("TestClient"));
        assert!(content.contains("#[errors("));
        assert!(content.contains("Validated<Json<T>>"));
        assert!(content.contains("IntoApiError"));
        assert!(content.contains("DocumentedError"));
    }

    #[test]
    fn test_generate_cursor_rules() {
        let content = generate_cursor_rules();
        assert!(content.contains("Rapina"));
        assert!(content.contains("#[public]"));
        assert!(content.contains("IntoApiError"));
        assert!(content.contains("DocumentedError"));
        assert!(content.contains("rapina add resource"));
    }
}
